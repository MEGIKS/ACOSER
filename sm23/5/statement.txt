Напишите функции для справедливого решения задачи читателей-писателей.
Справедливое решение задачи читателей-писателей должно удовлетворять следующим свойствам:

В критической секции одновременно может находиться не более одного писателя.
В критической секции одновременно может находиться произвольное количество читателей.
Нити, которые не могут войти в критическую секцию, не потребляют процессорного времени
  (отсутствует активное ожидание).
Нить, запросившая вход в критическую секцию позже, не может войти в критическую
  секцию перед нитью, запросившей критическую секцию раньше. То есть, если в критическую секцию входит некоторая нить, то нити, которые запросили критическую секцию раньше, либо уже вышли из критической секции, либо находятся в критической секции, либо выполняют вход в критическую секцию.
Нить-читатель может и должна войти в критическую секцию без ожидания,
  если либо критическая секция свободна, либо в критической секции есть читатели,
  и в очереди на вход перед данной нитью нет писателей.

Решение должно содержать следующие типы и функции:
Для хранения данных должна быть определена:
struct FairRwLock
{
    // ...
};

Должно быть определено typedef-имя:

typedef struct FairRwLock fair_rwlock_t;

Должен быть определен макрос:

#define FAIR_RWLOCK_INITIALIZER //...

Который предназначен для статической инициализации
переменной следующим образом:

fair_rwlock_t myrw = FAIR_RWLOCK_INITIALIZER;

Должны быть определены следующие функции:

void fair_rwlock_init(fair_rwlock_t *prw);      // инициализация
void fair_rwlock_destroy(fair_rwlock_t *prw);   // уничтожение
void fair_rwlock_wrlock(fair_rwlock_t *prw);    // запрос на вход в критическую секцию на запись
void fair_rwlock_rdlock(fair_rwlock_t *prw);    // запрос на вход в критическую секцию на чтение
void fair_rwlock_unlock(fair_rwlock_t *prw);    // выход из критической секции
